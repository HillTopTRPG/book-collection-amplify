name: Create PR and Tag and Release

on:
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version bump type'
        required: true
        default: 'patch'
        type: choice
        options:
          - major
          - minor
          - patch
      description:
        description: 'Release description (optional)'
        required: false
        type: string

jobs:
  create-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"


      - name: Check for changes between develop and main
        id: check_changes
        run: |
          git fetch origin develop
          git fetch origin main

          # Check if there are differences
          if git diff --quiet origin/main...origin/develop; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "No changes found between main and develop branches"
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "Changes found between main and develop branches"
          fi

      - name: Exit if no changes
        if: steps.check_changes.outputs.has_changes == 'false'
        run: |
          echo "‚ùå No changes found between main and develop branches. Exiting..."
          exit 1

      - name: Get repository owner
        id: repo_info
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { data: repo } = await github.rest.repos.get({
              owner: context.repo.owner,
              repo: context.repo.repo
            });

            console.log(`Repository owner: ${repo.owner.login}`);
            return repo.owner.login;

      - name: Calculate Final Version
        id: final_version
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const versionType = "${{ inputs.version_type }}";

            // Get all tags to find the latest version
            const { data: tags } = await github.rest.repos.listTags({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });

            console.log(`Found ${tags.length} existing tags`);
            if (tags.length > 0) {
              console.log('Existing tags:', tags.map(tag => tag.name).join(', '));
            }

            // Function to parse version string
            function parseVersion(version) {
              const cleanVersion = version.replace(/^v/, ''); // Remove 'v' prefix if present
              const parts = cleanVersion.split('.').map(num => parseInt(num) || 0);
              return {
                major: parts[0] || 0,
                minor: parts[1] || 0,
                patch: parts[2] || 0,
                original: version
              };
            }

            // Function to compare versions
            function compareVersions(a, b) {
              if (a.major !== b.major) return b.major - a.major;
              if (a.minor !== b.minor) return b.minor - a.minor;
              return b.patch - a.patch;
            }

            // Find the latest version
            let latestVersion = { major: 0, minor: 0, patch: 0 };
            if (tags.length > 0) {
              const versions = tags.map(tag => parseVersion(tag.name)).filter(v =>
                !isNaN(v.major) && !isNaN(v.minor) && !isNaN(v.patch)
              );

              console.log('Parsed versions:', versions.map(v => `${v.major}.${v.minor}.${v.patch}`).join(', '));

              if (versions.length > 0) {
                versions.sort(compareVersions);
                latestVersion = versions[0];
                console.log(`Latest version found: ${latestVersion.major}.${latestVersion.minor}.${latestVersion.patch}`);
                console.log('All versions after sorting:', versions.map(v => `${v.major}.${v.minor}.${v.patch}`).join(', '));
              }
            } else {
              console.log('No existing tags found, starting from 0.0.0');
            }

            // Calculate new version based on version type
            let newVersion;
            switch (versionType) {
              case 'major':
                newVersion = `${latestVersion.major + 1}.0.0`;
                break;
              case 'minor':
                newVersion = `${latestVersion.major}.${latestVersion.minor + 1}.0`;
                break;
              case 'patch':
              default:
                newVersion = `${latestVersion.major}.${latestVersion.minor}.${latestVersion.patch + 1}`;
                break;
            }

            console.log(`Calculated final version: ${newVersion}`);

            // Set output for the step
            core.setOutput('version', newVersion);
            return newVersion;

      - name: Read release template and generate changelog
        id: changelog
        run: |
          # Read the release template
          if [ -f ".github/RELEASE_WORKFLOW_TEMPLATE.md" ]; then
            TEMPLATE_CONTENT=$(cat .github/RELEASE_WORKFLOW_TEMPLATE.md)
            echo "‚úÖ Found release template"
          else
            echo "‚ö†Ô∏è Release template not found, using default format"
            # Create default template content
            echo "## Ë¶ÅÁÇπ" > temp_template.md
            echo "" >> temp_template.md
            echo "## Â§âÊõ¥ÁÇπ" >> temp_template.md
            echo "" >> temp_template.md
            echo "| before | after |" >> temp_template.md
            echo "| ------ | ----- |" >> temp_template.md
            echo "" >> temp_template.md
            echo "## „ÉÅ„Çß„ÉÉ„ÇØ„É™„Çπ„Éà" >> temp_template.md
            echo "" >> temp_template.md
            echo "- [ ] „Éû„Éº„Ç∏ÂØæË±°„ÅÆ„Éñ„É©„É≥„ÉÅ„ÅØÂêà„Å£„Å¶„ÅÑ„Çã„Åã" >> temp_template.md
            echo "- [ ] ‰ΩôË®à„Å™Ê®ôÊ∫ñÂá∫Âäõ„Å™„Å©„ÅåÊ∑∑„Åò„Å£„Å¶„ÅÑ„Å™„ÅÑ„Åã" >> temp_template.md
            TEMPLATE_CONTENT=$(cat temp_template.md)
            rm temp_template.md
          fi

          # Get commits between main and develop for changelog
          git fetch origin main
          git fetch origin develop

          echo "## üìù Changes in this release" > changelog.md
          echo "" >> changelog.md
          git log origin/main..origin/develop --pretty=format:"- %s (%h)" >> changelog.md
          COMMIT_CHANGES=$(cat changelog.md)

          # Set outputs
          echo "template_content<<EOF" >> $GITHUB_OUTPUT
          echo "$TEMPLATE_CONTENT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "commit_changes<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMIT_CHANGES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create Pull Request
        id: create_pr
        uses: actions/github-script@v7
        env:
          TEMPLATE_CONTENT: ${{ steps.changelog.outputs.template_content }}
          COMMIT_CHANGES: ${{ steps.changelog.outputs.commit_changes }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const repoOwner = ${{ steps.repo_info.outputs.result }};
            const newVersion = "${{ steps.final_version.outputs.version }}";
            const versionType = "${{ inputs.version_type }}";
            const description = "${{ inputs.description }}" || "";

            // Read the outputs directly from environment
            const templateContent = process.env.TEMPLATE_CONTENT || "";
            const commitChanges = process.env.COMMIT_CHANGES || "";

            let prBody = `üöÄ **Release ${newVersion}** (${versionType} version bump)\n\n`;

            if (description) {
              prBody += description + '\n\n';
            }

            prBody += templateContent + '\n\n';
            prBody += commitChanges + '\n\n';
            prBody += '---\n\n';
            prBody += `‚ö° This PR was automatically created by GitHub Actions.\n`;
            prBody += `üè∑Ô∏è Merging this PR will create tag \`${newVersion}\` and release.`;

            try {
              const { data: pr } = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `[v${newVersion}]`,
                head: 'develop',
                base: 'main',
                body: prBody,
                draft: false
              });

              // Create release label if it doesn't exist
              try {
                await github.rest.issues.getLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: 'release'
                });
                console.log('‚úÖ Release label already exists');
              } catch (error) {
                if (error.status === 404) {
                  await github.rest.issues.createLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    name: 'release',
                    color: 'ff6b6b',
                    description: 'Release pull requests'
                  });
                  console.log('‚úÖ Created release label');
                }
              }

              // Add release label to PR
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  labels: ['release']
                });
                console.log('‚úÖ Added release label to PR');
              } catch (labelError) {
                console.log(`‚ö†Ô∏è Could not add release label: ${labelError.message}`);
              }

              // Add reviewer (repository owner)
              if (repoOwner !== 'github-actions[bot]') {
                try {
                  await github.rest.pulls.requestReviewers({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: pr.number,
                    reviewers: [repoOwner]
                  });
                  console.log(`‚úÖ Added ${repoOwner} as reviewer`);
                } catch (reviewerError) {
                  console.log(`‚ö†Ô∏è Could not add reviewer: ${reviewerError.message}`);
                }
              }

              // Enable auto-merge with squash
              try {
                await github.rest.pulls.enableAutoMerge({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number,
                  merge_method: 'squash'
                });
                console.log('‚úÖ Enabled auto-merge (squash) for PR');
              } catch (autoMergeError) {
                console.log(`‚ö†Ô∏è Could not enable auto-merge: ${autoMergeError.message}`);
                console.log('Manual merge will be required');

                // Log detailed error information for debugging
                if (autoMergeError.response) {
                  console.log(`Error status: ${autoMergeError.response.status}`);
                  console.log(`Error data:`, JSON.stringify(autoMergeError.response.data, null, 2));
                }
              }

              console.log(`‚úÖ Created PR #${pr.number}: ${pr.title}`);
              console.log(`üîó URL: ${pr.html_url}`);

              return {
                number: pr.number,
                url: pr.html_url,
                title: pr.title
              };

            } catch (error) {
              if (error.status === 422 && error.message.includes('No commits between')) {
                throw new Error('No commits between main and develop branches');
              }
              throw error;
            }

      - name: Create Tag and Release
        id: create_release
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const changelogContent = `${{ steps.changelog.outputs.changelog_content }}`;
            const description = "${{ inputs.description }}" || "";
            const newVersion = "${{ steps.final_version.outputs.version }}";
            const prInfo = ${{ steps.create_pr.outputs.result }};

            console.log(`Using final version: ${newVersion}`);

            // Get the latest commit from develop branch
            const { data: developBranch } = await github.rest.repos.getBranch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              branch: 'develop'
            });

            const tagSha = developBranch.commit.sha;

            try {
              // Create tag
              await github.rest.git.createTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: newVersion,
                message: `Release ${newVersion}`,
                object: tagSha,
                type: 'commit'
              });

              // Create tag reference
              await github.rest.git.createRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `refs/tags/${newVersion}`,
                sha: tagSha
              });

              console.log(`‚úÖ Created tag: ${newVersion}`);

              // Create release
              const releaseBody = `${description ? description + '\n\n' : ''}${changelogContent}

              ---

              üîó **Related Pull Request:** #${prInfo.number}
              üìÖ **Released:** ${new Date().toISOString().split('T')[0]}`;

              const { data: release } = await github.rest.repos.createRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag_name: newVersion,
                name: newVersion,
                body: releaseBody,
                draft: false,
                prerelease: false
              });

              console.log(`‚úÖ Created release: ${release.name}`);
              console.log(`üîó Release URL: ${release.html_url}`);

              return {
                tag: newVersion,
                release_url: release.html_url,
                release_id: release.id
              };

            } catch (error) {
              console.error('Error creating tag/release:', error);
              throw error;
            }

      - name: Summary
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prInfo = ${{ steps.create_pr.outputs.result }};
            const releaseInfo = ${{ steps.create_release.outputs.result }};

            console.log('üéâ Release Process Completed!');
            console.log('');
            console.log('üìã Summary:');
            console.log(`- Version: ${releaseInfo.tag}`);
            console.log(`- Pull Request: #${prInfo.number} (${prInfo.url})`);
            console.log(`- Tag: ${releaseInfo.tag}`);
            console.log(`- Release: ${releaseInfo.release_url}`);
            console.log('');
            console.log('‚úÖ Next steps:');
            console.log('1. Review the Pull Request');
            console.log('2. Merge the PR when ready');
            console.log('3. The release is already published!');

      - name: Comment on PR with release info
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prInfo = ${{ steps.create_pr.outputs.result }};
            const releaseInfo = ${{ steps.create_release.outputs.result }};

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prInfo.number,
              body: `üè∑Ô∏è **Tag and Release Created!**

              - **Tag:** \`${releaseInfo.tag}\`
              - **Release:** [${releaseInfo.tag}](${releaseInfo.release_url})

              The release has been published and is ready! üéâ
              Merge this PR to complete the release process.`
            });