name: Create Release PR and Tag

on:
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version bump type'
        required: true
        default: 'patch'
        type: choice
        options:
          - major
          - minor
          - patch
      description:
        description: 'Release description (optional)'
        required: false
        type: string

jobs:
  create-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Get latest tag and calculate new version
        id: version
        run: |
          # Get the latest tag (fallback to 0.0.0 if no tags exist)
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "0.0.0")
          echo "Latest tag: $LATEST_TAG"

          # Remove 'v' prefix if present
          LATEST_TAG=${LATEST_TAG#v}

          # Split version into parts
          IFS='.' read -r -a VERSION_PARTS <<< "$LATEST_TAG"
          MAJOR=${VERSION_PARTS[0]:-0}
          MINOR=${VERSION_PARTS[1]:-0}
          PATCH=${VERSION_PARTS[2]:-0}

          echo "Current version: $MAJOR.$MINOR.$PATCH"

          # Calculate new version based on input
          case "${{ inputs.version_type }}" in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac

          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          echo "New version: $NEW_VERSION"

          # Set outputs
          echo "current_version=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "version_type=${{ inputs.version_type }}" >> $GITHUB_OUTPUT

      - name: Check for changes between develop and main
        id: check_changes
        run: |
          git fetch origin develop
          git fetch origin main

          # Check if there are differences
          if git diff --quiet origin/main...origin/develop; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "No changes found between main and develop branches"
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "Changes found between main and develop branches"
          fi

      - name: Exit if no changes
        if: steps.check_changes.outputs.has_changes == 'false'
        run: |
          echo "‚ùå No changes found between main and develop branches. Exiting..."
          exit 1

      - name: Get repository owner
        id: repo_info
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { data: repo } = await github.rest.repos.get({
              owner: context.repo.owner,
              repo: context.repo.repo
            });

            console.log(`Repository owner: ${repo.owner.login}`);
            return repo.owner.login;

      - name: Read release template and generate changelog
        id: changelog
        run: |
          # Read the release template
          if [ -f ".github/RELEASE_WORKFLOW_TEMPLATE.md" ]; then
            TEMPLATE_CONTENT=$(cat .github/RELEASE_WORKFLOW_TEMPLATE.md)
            echo "‚úÖ Found release template"
          else
            echo "‚ö†Ô∏è Release template not found, using default format"
            # Create default template content
            echo "## Ë¶ÅÁÇπ" > temp_template.md
            echo "" >> temp_template.md
            echo "## Â§âÊõ¥ÁÇπ" >> temp_template.md
            echo "" >> temp_template.md
            echo "| before | after |" >> temp_template.md
            echo "| ------ | ----- |" >> temp_template.md
            echo "" >> temp_template.md
            echo "## „ÉÅ„Çß„ÉÉ„ÇØ„É™„Çπ„Éà" >> temp_template.md
            echo "" >> temp_template.md
            echo "- [ ] „Éû„Éº„Ç∏ÂØæË±°„ÅÆ„Éñ„É©„É≥„ÉÅ„ÅØÂêà„Å£„Å¶„ÅÑ„Çã„Åã" >> temp_template.md
            echo "- [ ] ‰ΩôË®à„Å™Ê®ôÊ∫ñÂá∫Âäõ„Å™„Å©„ÅåÊ∑∑„Åò„Å£„Å¶„ÅÑ„Å™„ÅÑ„Åã" >> temp_template.md
            TEMPLATE_CONTENT=$(cat temp_template.md)
            rm temp_template.md
          fi

          # Get commits between main and develop for changelog
          git fetch origin main
          git fetch origin develop

          echo "## üìù Changes in this release" > changelog.md
          echo "" >> changelog.md
          git log origin/main..origin/develop --pretty=format:"- %s (%h)" >> changelog.md
          COMMIT_CHANGES=$(cat changelog.md)

          # Set outputs
          echo "template_content<<EOF" >> $GITHUB_OUTPUT
          echo "$TEMPLATE_CONTENT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "commit_changes<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMIT_CHANGES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create Pull Request
        id: create_pr
        uses: actions/github-script@v7
        env:
          TEMPLATE_CONTENT: ${{ steps.changelog.outputs.template_content }}
          COMMIT_CHANGES: ${{ steps.changelog.outputs.commit_changes }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const repoOwner = ${{ steps.repo_info.outputs.result }};
            const newVersion = "${{ steps.version.outputs.new_version }}";
            const versionType = "${{ steps.version.outputs.version_type }}";
            const description = "${{ inputs.description }}" || "";

            // Read the outputs directly from environment
            const templateContent = process.env.TEMPLATE_CONTENT || "";
            const commitChanges = process.env.COMMIT_CHANGES || "";

            let prBody = `üöÄ **Release ${newVersion}** (${versionType} version bump)\n\n`;

            if (description) {
              prBody += description + '\n\n';
            }

            prBody += templateContent + '\n\n';
            prBody += commitChanges + '\n\n';
            prBody += '---\n\n';
            prBody += `‚ö° This PR was automatically created by GitHub Actions.\n`;
            prBody += `üè∑Ô∏è Merging this PR will create tag \`${newVersion}\` and release.`;

            try {
              const { data: pr } = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `[v${newVersion}]`,
                head: 'develop',
                base: 'main',
                body: prBody,
                draft: false
              });

              // Create release label if it doesn't exist
              try {
                await github.rest.issues.getLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: 'release'
                });
                console.log('‚úÖ Release label already exists');
              } catch (error) {
                if (error.status === 404) {
                  await github.rest.issues.createLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    name: 'release',
                    color: 'ff6b6b',
                    description: 'Release pull requests'
                  });
                  console.log('‚úÖ Created release label');
                }
              }

              // Add release label to PR
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  labels: ['release']
                });
                console.log('‚úÖ Added release label to PR');
              } catch (labelError) {
                console.log(`‚ö†Ô∏è Could not add release label: ${labelError.message}`);
              }

              // Add reviewer (repository owner)
              if (repoOwner !== 'github-actions[bot]') {
                try {
                  await github.rest.pulls.requestReviewers({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: pr.number,
                    reviewers: [repoOwner]
                  });
                  console.log(`‚úÖ Added ${repoOwner} as reviewer`);
                } catch (reviewerError) {
                  console.log(`‚ö†Ô∏è Could not add reviewer: ${reviewerError.message}`);
                }
              }

              // Enable auto-merge with squash
              try {
                await github.rest.pulls.merge({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number,
                  merge_method: 'squash',
                  commit_title: pr.title
                });
                console.log('‚úÖ Enabled auto-merge (squash) for PR');
              } catch (mergeError) {
                // If direct merge fails, try to enable auto-merge
                try {
                  await github.rest.pulls.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: pr.number,
                    auto_merge: {
                      merge_method: 'squash',
                      commit_title: pr.title
                    }
                  });
                  console.log('‚úÖ Enabled auto-merge for PR');
                } catch (autoMergeError) {
                  console.log(`‚ö†Ô∏è Could not enable auto-merge: ${autoMergeError.message}`);
                  console.log('Manual merge will be required');
                }
              }

              console.log(`‚úÖ Created PR #${pr.number}: ${pr.title}`);
              console.log(`üîó URL: ${pr.html_url}`);

              return {
                number: pr.number,
                url: pr.html_url,
                title: pr.title
              };

            } catch (error) {
              if (error.status === 422 && error.message.includes('No commits between')) {
                throw new Error('No commits between main and develop branches');
              }
              throw error;
            }

      - name: Create Tag and Release
        id: create_release
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const newVersion = "${{ steps.version.outputs.new_version }}";
            const changelogContent = `${{ steps.changelog.outputs.changelog_content }}`;
            const description = "${{ inputs.description }}" || "";
            const prInfo = ${{ steps.create_pr.outputs.result }};

            // Get the latest commit from develop branch
            const { data: developBranch } = await github.rest.repos.getBranch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              branch: 'develop'
            });

            const tagSha = developBranch.commit.sha;

            try {
              // Create tag
              await github.rest.git.createTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: newVersion,
                message: `Release ${newVersion}`,
                object: tagSha,
                type: 'commit'
              });

              // Create tag reference
              await github.rest.git.createRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `refs/tags/${newVersion}`,
                sha: tagSha
              });

              console.log(`‚úÖ Created tag: ${newVersion}`);

              // Create release
              const releaseBody = `${description ? description + '\n\n' : ''}${changelogContent}

              ---

              üîó **Related Pull Request:** #${prInfo.number}
              üìÖ **Released:** ${new Date().toISOString().split('T')[0]}`;

              const { data: release } = await github.rest.repos.createRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag_name: newVersion,
                name: newVersion,
                body: releaseBody,
                draft: false,
                prerelease: false
              });

              console.log(`‚úÖ Created release: ${release.name}`);
              console.log(`üîó Release URL: ${release.html_url}`);

              return {
                tag: newVersion,
                release_url: release.html_url,
                release_id: release.id
              };

            } catch (error) {
              console.error('Error creating tag/release:', error);
              throw error;
            }

      - name: Summary
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prInfo = ${{ steps.create_pr.outputs.result }};
            const releaseInfo = ${{ steps.create_release.outputs.result }};
            const newVersion = "${{ steps.version.outputs.new_version }}";

            console.log('üéâ Release Process Completed!');
            console.log('');
            console.log('üìã Summary:');
            console.log(`- Version: ${newVersion}`);
            console.log(`- Pull Request: #${prInfo.number} (${prInfo.url})`);
            console.log(`- Tag: ${releaseInfo.tag}`);
            console.log(`- Release: ${releaseInfo.release_url}`);
            console.log('');
            console.log('‚úÖ Next steps:');
            console.log('1. Review the Pull Request');
            console.log('2. Merge the PR when ready');
            console.log('3. The release is already published!');

      - name: Comment on PR with release info
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prInfo = ${{ steps.create_pr.outputs.result }};
            const releaseInfo = ${{ steps.create_release.outputs.result }};
            const newVersion = "${{ steps.version.outputs.new_version }}";

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prInfo.number,
              body: `üè∑Ô∏è **Tag and Release Created!**

              - **Tag:** \`${newVersion}\`
              - **Release:** [${newVersion}](${releaseInfo.release_url})

              The release has been published and is ready! üéâ
              Merge this PR to complete the release process.`
            });
